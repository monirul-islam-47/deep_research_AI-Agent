import os
import click # For creating the CLI
from datetime import datetime
from dotenv import load_dotenv

# Import the main research function from our agent
from research_agent import run_deep_research

# Load environment variables from .env at the very beginning
load_dotenv()

# --- Configuration ---
# Default research depth, can be overridden by .env or CLI argument.
# The Go project's default depth is 2.
DEFAULT_MAX_DEPTH = int(os.getenv("MAX_DEPTH", 2))
DEFAULT_OUTPUT_PREFIX = "research_report"

# --- Helper Function for Saving Output ---
def save_research_to_markdown(initial_query: str, final_answer: str, all_research_data: list, filename_prefix: str):
    """
    Saves the research findings and final answer to a timestamped markdown file.
    """
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    # Sanitize a part of the query for a more descriptive filename
    safe_query_part = "".join(c if c.isalnum() else "_" for c in initial_query[:40]).strip("_")
    filename = f"{filename_prefix}_{safe_query_part}_{timestamp}.md"

    print(f"üíæ Saving research report to: {filename}")
    try:
        with open(filename, "w", encoding="utf-8") as f:
            f.write(f"# Deep Research Report\n\n")
            f.write(f"**Initial Query:** \"{initial_query}\"\n\n")
            f.write(f"**Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            f.write("## üèÅ Final Synthesized Answer\n\n")
            f.write(f"{final_answer}\n\n")
            
            f.write("---\n\n")
            f.write("## üìö Detailed Research Steps & Findings\n\n")

            if not all_research_data:
                f.write("No detailed research steps were recorded (e.g., initial query too broad, or no content found).\n\n")
            else:
                # Group by depth for potentially better readability if output gets very long
                # For now, iterate as processed
                for item in all_research_data:
                    f.write(f"### üîé Step: Depth {item['depth']} - Searched for: \"{item['query']}\"\n\n")
                    f.write(f"- **Source URL:** [{item.get('title', 'N/A')}]({item['url']})\n")
                    f.write(f"- **LLM Summary of Source:**\n")
                    f.write(f"  ```text\n  {item.get('summary', 'No summary extracted.')}\n  ```\n")
                    
                    generated_queries = item.get('generated_queries')
                    if generated_queries:
                        f.write(f"- **LLM Suggested Next Queries from this Source:**\n")
                        for i, gq_val in enumerate(generated_queries):
                            if i == 0 and gq_val.strip(): # Highlight the one pursued
                                f.write(f"  - **`{gq_val}` (Pursued if valid)**\n")
                            else:
                                f.write(f"  - `{gq_val}`\n")
                    else:
                        f.write(f"- **LLM Suggested Next Queries:** None\n")
                    
                    # Optionally include raw content snippet (can make file very large)
                    # f.write(f"- **Raw Content Snippet (first 250 chars):**\n")
                    # f.write(f"  ```text\n  {item.get('raw_content_snippet', '')}\n  ```\n\n")
                    f.write("\n---\n\n")
            
            f.write(f"\n\n*Report generated by Deep Research Python Script.*\n")
        print(f"‚úÖ Research report successfully saved to: {filename}")
    except IOError as e:
        print(f"‚ùå Error saving report to {filename}: {e}")


# --- CLI Definition using Click ---
@click.command()
@click.option(
    '--query', '-q',
    required=True,
    help="The initial research query string."
)
@click.option(
    '--depth', '-d',
    default=DEFAULT_MAX_DEPTH,
    type=int,
    show_default=True,
    help="Maximum research depth for iterative queries."
)
@click.option(
    '--output', '-o',
    default=DEFAULT_OUTPUT_PREFIX,
    show_default=True,
    help="Prefix for the output markdown filename."
)
def cli_main(query: str, depth: int, output: str):
    """
    Deep Research Tool - Python Version

    This tool performs iterative, depth-first research on a given topic.
    It uses web searches (DuckDuckGo) and LLM analysis (OpenAI)
    to gather information, generate sub-queries, and synthesize a final answer.
    The process mirrors the logic of the dzhng/deep-research Go project.
    """
    print(f"üöÄ Initializing Deep Research Tool...")
    print(f"   Query: \"{query}\"")
    print(f"   Max Depth: {depth}")
    print(f"   Output File Prefix: {output}")
    
    # Check for OpenAI API Key early
    openai_api_key = os.getenv("OPENAI_API_KEY")
    if not openai_api_key:
        print("\n‚ùå CRITICAL ERROR: The OPENAI_API_KEY environment variable is not set.")
        print("   Please create a .env file in the project root with your OpenAI API key:")
        print("   Example .env content:")
        print("   OPENAI_API_KEY=\"your_actual_api_key_here\"")
        print("\n   Alternatively, ensure the OPENAI_API_KEY is set in your system's environment variables.")
        return # Exit if key is missing

    print("\n‚è≥ Starting research process...\n")
    final_answer, all_research_data = run_deep_research(query, depth)

    print("\n\n--- Research Process Concluded ---")

    if not all_research_data and (not final_answer or "No research data was collected" in final_answer):
        print("üòî The research process did not yield any data or a substantive final answer.")
        print("   This might be due to: restrictive search results, inability to scrape content,")
        print("   or the initial query being too niche or broad for effective automated research.")
    else:
        # Even if all_research_data is empty, final_answer might have a generic message.
        # Always try to save what we have.
        save_research_to_markdown(query, final_answer, all_research_data, filename_prefix=output)
        if not all_research_data:
             print("\nNote: While a final answer (or message) was generated, no detailed intermediate research steps were recorded.")


if __name__ == '__main__':
    cli_main()